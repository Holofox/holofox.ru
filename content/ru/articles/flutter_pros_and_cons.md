---
title: "Плюсы и минусы перехода на Flutter"
description: ""
date: 2023-01-29
tags: ["flutter", "kotlin", "dart", "java", "swift", "google", "apple"]
summary: "Что нужно знать разработчику, чтобы перейти на **Flutter**? Разберемся, с какими особенностями можно
столкнуться
и стоит ли переходить на него."
---

Что нужно знать разработчику, чтобы перейти на **Flutter**? В статье будут упоминания нативных языков и инструментов,
которые приближены к привычному представлению процесса мобильной разработки, что поможет ближе познакомиться с
инструментами и технологиями, используемые во [Flutter](https://flutter.dev/).

## Что такое Flutter?

[Flutter](https://flutter.dev/) - это бесплатный и открытый набор инструментов для разработки кроссплатформенного
программного обеспечения, в котором используется язык [Dart](https://dart.dev/). Если вы знакомы с **Kotlin, Swift,
Java**
или даже **Typescript**, то **Dart** тоже может стать родственной душой.

Отличительные особенности:

* проект с открытым исходным кодом и сильным сообществом поддержки;
* собственный движок рендеринга, кроссплатформенность и единый язык разработки;
* безопасное взаимодействие с нативным кодом по каналу платформы;
* высокая производительность по отношению к другим кроссплатформенным инструментам.

## Плюсы

### Dart - главная причина, по которой разработчики любят Flutter

Начну с того, что **Dart** создавался командой **Google** как замена или альтернатива **JavaScript**. Начать писать на
этом языке
можно так же быстро, как и научиться ездить на велосипеде без рук. Начать можно с
небольшой [экскурсии](https://dart.dev/guides/language/language-tour). К слову, язык из коробки однопоточный, но
предоставляет механизм [Event Loop](https://dart.cn/articles/archive/event-loop), который помогает работать с
асихронными/параллельными операциями.

И всё это выглядит почти также, как [корутины](https://kotlinlang.org/docs/coroutines-overview.html)
в [Kotlin](https://kotlinlang.org/) или даже
как [Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html) в [Swift](https://www.swift.org/),
посмотрим и сравним синтаксис:

#### Dart

```dart
class Language {
  const Language(this.name);

  final String name;

  Future<void> learn(Duration duration) {
    return Future<void>.delayed(
      duration, () => print('Well done! $name is learned!'),
    );
  }
}

Future<void> main() async {
  final dart = Language('Dart');
  await dart.learn(Duration(seconds: 2));
}
```

#### Kotlin

```kotlin
import kotlinx.coroutines.delay

class Language(private val name: String) {
    suspend fun learn(duration: Long) {
        delay(duration)
        print("Well done! $name is learned!")
    }
}

suspend fun main() {
    val kotlin = Language("Kotlin")
    kotlin.learn(2000L)
}
```

#### Swift

```swift
import Foundation

class Language {
  let name: String

  init(name: String) {
    self.name = name
  }

  func learn(interval: TimeInterval) async throws -> Void {
    try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
    print("Well done! \(name) is learned!")
  }
}

Task.init {
  let swift = Language(name: "Swift")
  try await swift.learn(interval: 2.0)
}
```

Как можно заметить, **Dart** имеет хорошую визуальную эстетичность кода, но помимо этого ещё можно встретить поддержку:

* [нулевой безопасности](https://dart.dev/null-safety)
  и [статической типизации](https://dart.dev/guides/language/type-system);
* **just-in-time** в режиме разработки и **ahead-of-time** в режиме выпуска;
* [неявных интерфейсов](https://dart.dev/guides/language/language-tour#implicit-interfaces)
  и [расширений](https://dart.dev/guides/language/extension-methods).

### Простая и гибкая вёрстка

Пользовательский интерфейс является декларативным и состоит
из [виджетов](https://docs.flutter.dev/development/ui/widgets) – в своём роде компонентов, которые могут располагаться
на экране. Если сравнивать с привычными инструментами, можно попробовать привести
пример [Jetpack Compose](https://developer.android.com/jetpack/compose) для **Android**
и [SwiftUI](https://developer.apple.com/xcode/swiftui/) для **iOS**.

Для отрисовки виджетов используется графический движок [Skia](https://skia.org/), который во многом не требователен к
версии и самой платформе, что позволяет воплощать воистину невероятные вещи. Физика и сами виджеты стараются быть близки
к системным, повторяя гайдлайны той или иной системы, что открывает дополнительную возможность максимально их
кастомизировать под свои цели и задачи.

Познакомиться с компоновкой пользовательского интерфейса можно
с [введения](https://docs.flutter.dev/development/ui/widgets-intro) в виджеты.

### Быстрая адаптация к изменениям ОС

Многие кроссплатформенные инструменты подходят к новым изменениям ОС неохотно, что чаще всего сдерживает разработчиков
идти в ногу со временем. Рассмотрим пример с поддержкой
дисплеев [ProMotion](https://developer.apple.com/documentation/quartzcore/optimizing_promotion_refresh_rates_for_iphone_13_pro_and_ipad_pro)
с динамической частотой кадров. Для любого кроссплатформенного инструмента сейчас это является серьёзной задачей для
внесения изменений в ядро движка:

* внести ряд изменений, которые бы позволили работать с максимально эффективной частотой кадров для конкретных
  устройств;
* рассмотреть вопросы связанные с влиянием энергопотребления;

С выходом новой линейки **iPhone 13**, разработчикам сразу же стало интересно, как поведут себя приложения написанные на
**Flutter**. Чуда не произошло, и в первый же день продаж в репозитории
была [заведена](https://github.com/flutter/flutter/issues/90675) проблема, также
появлялись [первые наброски](https://github.com/flutter/engine/pull/30900), которые добавили бы такую поддержку. На
текущий момент есть поддержка через флаг, который по
умолчанию [прописывается](https://github.com/flutter/flutter/pull/94509) в проекте, но он жестко задан минимальной
частотой, что с одной стороны даёт возможность использовать экран на полную, а со второй -
приводит к потреблению аккумулятора.

**Flutter** поддерживается не только внутренней командой **Google**, но и открытым сообществом разработчиков, что
позволяет
радоваться таким небольшим мелочам вместе, поскольку совместные усилия приближают кроссплатформу всё ближе к нативной.

### Пакеты от сторонних разработчиков

На сегодняшний день, разработчики прикладывают максимальные усилия, чтобы оставить свой вклад в сообществе.
Программа [Flutter Favorite](https://docs.flutter.dev/development/packages-and-plugins/favorites) задаёт высокую планку
качества, на которую стоит ориентироваться начинающим разработчикам при выборе внешней зависимости в проект.

Стоит отметить, что сейчас сообщество находится в хорошем достатке стабильных пакетов, которые можно использовать в
рабочих проектах.

## Минусы

У любого инструмента появляются слабые места, с которыми сталкиваешься только тогда, когда начинаешь подходить к решению
серьёзных задач.

### Кодогенерация

Кодогенерация может показаться идеальным решением в сокращении времени разработчика на написание и поддержку рутинных
частей проекта, но это не всегда так. В **Dart** кодогенерация устроена таким образом, что её приходится перезапускать
каждый раз, чтобы увидеть новые изменения. В больших проектах такие моменты начинают играть в злую шутку с
разработчиками, отнимая большую часть времени для того, чтобы дождаться сгенерированной части кода (например, в **
CI/CD**).
Повесить слушателя можно, но это не всегда подходит по той причине, что он начинает реагировать на любые изменения в
коде, что приводит к частым обращениям к твердотельному накопителю и подвисаниям.

В **Kotlin** есть очень быстрый фоновый [KSP](https://kotlinlang.org/docs/ksp-quickstart.html) (или
даже [kapt](https://kotlinlang.org/docs/kapt.html)), с которыми приятно работать, в отличие
от [build_runner](https://dart.dev/tools/build_runner) в **Dart**. Кодогенерация в **Dart** до сих пор
требует [серьёзного переосмысления](https://github.com/flutter/flutter/issues/63323), чтобы закрыть потребности
большинства разработчиков.

### Имитация пользовательского взаимодействия

**Flutter** можно похвалить отличной поддержкой и оптимизацией только под одну платформу, под которую он затачивался в
первую очередь – **Android**. Если нативному **iOS**-разработчику дать пощупать приложение написанное на **Flutter**, то
он не
получит тот самый первоклассный пользовательский опыт от его использования. Физика и анимации лишь пытаются быть
похожими на те, к которым привык пользователь.

Разработчикам всё же удалось бесшовно повторить компоненты и физику в
стиле [Material Design](https://material.io/design), за
исключением [Human Interface Guidelines](https://developer.apple.com/design/), там физика и сами компоненты при
взаимодействии иногда ощущаются искусственными, как будто между пальцем и кнопкой существует ещё одна прослойка, которая
портит все ощущения от использования. И проблема даже не в самих компонентах, а в том, как **Flutter** в целом работает
на
этой платформе.

### Разный уровень производительности

Если говорить о веб-приложениях, то разработка на [Flutter Web](https://flutter.dev/web) будет требовать особый и
строгий подход
в [оптимизации](https://medium.com/flutter/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading-535fbe3cd674)
, что в целом заставит переосмыслить её целесообразность. Хочется предостеречь использование этой платформы для
разработки прогрессивных веб-приложений (**PWA**) или одностраничных приложений (**SPA**), поскольку их
производительность может
значительно уступать другим инструментам, что в итоге негативно сложится на общем впечатлении пользователя и
разработчика.

А ещё Flutter в настоящее
время [не поддерживает](https://docs.flutter.dev/deployment/android#what-are-the-supported-target-architectures) сборку
проекта под **x86** архитектуру для **Android**. Считается, что количество таких устройств на рынке не так велико, и с
каждым днём их становится всё меньше, а изменения, которые необходимо внести для реализации скомпилированных файлов для
этой архитектуры, потребуют [значительного](https://github.com/flutter/flutter/issues/9253) объёма работ в
компиляторе **Dart**. Можно также подробнее ознакомиться
с [поддерживаемыми](https://docs.flutter.dev/development/tools/sdk/release-notes/supported-platforms) платформами, чтобы
определиться, подходит ли Flutter для ваших целей.

Стоит упомянуть, что написать приложение под **watchOS** также не получится, однако
есть [возможность](https://docs.flutter.dev/development/platform-integration/apple-watch) встроить собственное нейтив
расширение в текущее приложение **Flutter**.

### Анализатор желает быть лучше

Когда в проектах участвуют несколько разработчиков, то чаще всего бывает, что после очередного рефакторинга остаются
неиспользуемые поля, методы, классы, файлы и т.д., что в конечном итоге порождает взаимосвязанную цепочку мёртвого кода,
о существовании которой можно узнать не сразу.

Из коробки доступен [analyzer](https://pub.dev/packages/analyzer), его можно настроить
различными [правилами](https://dart-lang.github.io/linter/lints/), но они скованы определёнными типами
предупреждений/ошибок, не позволяющие проводить дорогостоящие операции по нахождению неиспользуемых методов, классов и
т.п.

В качестве частичного решения проблемы можно
использовать [Dart Code Metrics](https://github.com/dart-code-checker/dart-code-metrics), но в больших проектах будет
ощущаться низкая скорость проведения статистического анализа, что в своём роде тоже доставляет неудобства.

## Ни туда, ни сюда

Я постарался собрать общие рабочие моменты, присуще кроссплатформенной разработке, чтобы предупредить о возможных
особенностях, с которыми можно столкнуться по мере разработки продукта на **Flutter**.

### Различия платформ пугают

В кроссплатформенном подходе, не все дизайнеры готовы воплощать привычный пользователям **UI/UX** для различных
платформ.
Обычно выбирается что-то среднее и чаще всего основой в дизайне
выступает [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/). Этим часто
злоупотребляют, что приводит к галактическим проблемам.

В макете может присутствовать функциональный компонент, который будет привычен одной платформе, но непривычен другой.
Поэтому, некоторые компоненты всё же необходимо адаптировать под поведение конкретной платформы, чтобы снизить негатив и
недопонимание со стороны пользователей.

### Одна кодовая база

Поддерживать кроссплатформенное приложение на одной кодовой базе – интересное приключение, поскольку код с виду и один,
но условия для взаимодействия с каждой платформой могут быть совершенно разные. Неправильно заложенная архитектура может
сильно увеличить сроки на тестирование и поддержку.

Здесь также стоит задумываться о том, какой функционал стоит проверять на разных платформах, а какой можно и на одной -
этой особенностью необходимо активно пользоваться, если был выбран кроссплатформенный инструмент.

## Выводы

Flutter является современным и быстрым решением для разработки кроссплатформенных приложений. Несмотря на свои
особенности, через некоторое время всё может измениться настолько, что текущие минусы больше не будут иметь значимость,
а на их смену придут новые, поскольку с каждым днём достигаются маленькие победы, которые в конечном итоге меняют
представление людей о кроссплатформенных инструментах.

Кратко резюмируя основные тезисы статьи:

1. **Dart** — это простой язык, который легче освоить, чем **Kotlin/Swift/Java**.
2. Виджеты позволяют очень быстро и гибко реализовывать сложные пользовательские представления.
3. **Flutter** в ногу со временем адаптируется к аппаратным или программным изменениям.
4. **Flutter** имеет активное сообщество разработчиков, различные пакеты и программы для повышения их качества.
5. Кодогенерация и статистический анализ кода требуют больше вовлеченности команды в улучшении этих инструментов.
6. Производительность может отличаться от платформы к платформе, поэтому необходимо определиться с целевым
   предназначением.
7. Пользовательское взаимодействие на некоторых платформах может отличаться от нативных.
8. Кроссплатформенные проекты, как правило, требуют особого подхода к построению проектов.
